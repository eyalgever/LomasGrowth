/*#pragma kernel CSMain
 
AppendStructuredBuffer<float3> buffer;
float size;
 
[numthreads(MAX_LINKS,MAX_LINKS,MAX_LINKS)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 center = float3(id / size);
    buffer.Append(center);
}
*/

#define BLOCKSIZE 64
#define MAX_LINKS 16

#pragma kernel GenerateMesh
#pragma kernel Collision
#pragma kernel Normal
#pragma kernel Bulge
#pragma kernel Plane
#pragma kernel Spring
#pragma kernel Split
#pragma kernel Integrate
#pragma kernel RotateTest


// uniforms 
float _maxNeighbors;
float _radius;
float _collisionFactor;
float _bulgeFactor;
float _springFactor;
float _springLength;
float _planarFactor;
float _dampening;
float _foodExponent;
float _threshold;
uint _numParticles;
uint _frameNum;

struct Particle
{
    int links[MAX_LINKS];
    int numLinks;
    int age;
    float food;
    float curvature;
    float3 position;
    float3 delta;
    float3 normal;
};

struct Vertex
{
    float3 vPosition;
    float3 vNormal;
};

struct Triangle
{
    Vertex v[3];
};

AppendStructuredBuffer<Triangle> TriangleAppendBufffer;
RWStructuredBuffer<Particle> ParticleRWBuffer;

int GetNext(int p, int previousIndex, int currentIndex)
{
    Particle current = ParticleRWBuffer[currentIndex];
    Particle thisParticle = ParticleRWBuffer[p];

    for (int i = 0; i < thisParticle.numLinks; i++)
    {
        for (int j = 0; j < current.numLinks; j++)
        {
            if ((thisParticle.links[i] == current.links[j]) &&
                (thisParticle.links[i] != previousIndex) && (thisParticle.links[i] != currentIndex))
            {
                return thisParticle.links[i];
            }
        }
    }

    return -19;
}

int GetNext(int p, int currentIndex)
{
    return GetNext(p, currentIndex, currentIndex);
}

void OrderLinks(int p)
{
    if (ParticleRWBuffer[p].numLinks < 3)
        return;
    
    int orderedLinks[MAX_LINKS];

    orderedLinks[0] = ParticleRWBuffer[p].links[0];
    orderedLinks[1] = GetNext(p, ParticleRWBuffer[p].links[0]);

    for (int i = 2; i < ParticleRWBuffer[p].numLinks; i++)
    {
        orderedLinks[i] = GetNext(p, orderedLinks[i - 2], orderedLinks[i - 1]);
    }

    for (int ii = 0; ii < ParticleRWBuffer[p].numLinks; ii++)
    {
        ParticleRWBuffer[p].links[ii] = orderedLinks[ii];
    }
}

int orientation(float3 p1, float3 p2, float3 p3)
{
    int val = (p2.y - p1.y) * (p3.x - p2.x) -
              (p2.x - p1.x) * (p3.y - p2.y);
  
    if (val == 0)
        return 0; // colinear 
  
    return (val > 0) ? -1 : 1; // clock or counterclock wise 
}

[numthreads(BLOCKSIZE, 1, 1)]
void GenerateMesh(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _numParticles)
        return;

    Particle p = ParticleRWBuffer[id.x];
    OrderLinks(id.x);

    for (int i = 0; i < p.numLinks; i++)
    { 
        
        Particle p1 = ParticleRWBuffer[p.links[i]];
        Particle p2 = ParticleRWBuffer[p.links[(i + 1) % (float) p.numLinks]];

        Triangle t;

        Vertex v0;
        Vertex v1;
        Vertex v2;

        v0.vPosition = p.position;
        v1.vPosition = p1.position;
        v2.vPosition = p2.position;
        
        float oo = orientation(p.position, p1.position, p2.position);

        float3 pp1 = normalize(p2.position - p.position);
        float3 pp2 = normalize(p1.position - p.position);
        float3 normal = normalize(oo * cross(pp1, pp2));

        v0.vNormal = normal;
        v1.vNormal = normal;
        v2.vNormal = normal;

        t.v[0] = v0;
        t.v[1] = v1;
        t.v[2] = v2;

        TriangleAppendBufffer.Append(t);
    }
}

[numthreads(BLOCKSIZE, 1, 1)]
void Collision(uint id : SV_DispatchThreadID)
{
    Particle p = ParticleRWBuffer[id.x];

    float r2 = max(0.001f, _radius * _radius);
    for (int i = 0; i < _numParticles; i ++)
    {
        if ( i != id.x)
        {
            float3 displacement = (p.position - ParticleRWBuffer[i].position);
            float d2 = dot(displacement, displacement);

            if (length(displacement) < _radius)
            {
                displacement = normalize(displacement);
                displacement *= (r2 - d2) / r2;

                p.delta += displacement * _collisionFactor;
            }
        }
    }

    ParticleRWBuffer[id.x] = p;
}

void ReverseLinks(int p)
{
    Particle part = ParticleRWBuffer[p];
      
    for (int i = 0; i < MAX_LINKS/2; i++)
    {
        if (i >= part.numLinks / 2)
            break;

        int tmp = part.links[i];
        ParticleRWBuffer[p].links[i] = part.links[part.numLinks - 1 - i];
        ParticleRWBuffer[p].links[part.numLinks - 1 - i] = tmp;
    }
}

void CalculateNormal(int index)
{
    float3 tmpNormal = (float3) 0.0;
    Particle p = ParticleRWBuffer[index];

    OrderLinks(index);
    
    for (uint i = 0; i < p.numLinks; i++)
    {
        float3 c = ParticleRWBuffer[p.links[i]].position;
        float3 d = ParticleRWBuffer[p.links[(i + 1) % p.numLinks]].position;
        tmpNormal += cross(d, c);
    }

    ParticleRWBuffer[index].normal = normalize(p.position);

  
   /* if (-1 == orientation(
        p.position,
        ParticleRWBuffer[p.links[0]].position,
        ParticleRWBuffer[p.links[1]].position))
    {
        ParticleRWBuffer[index].normal = -ParticleRWBuffer[index].normal;
        ReverseLinks(index);
    }
 */
}

[numthreads(BLOCKSIZE, 1, 1)]
void Normal(uint id : SV_DispatchThreadID)
{
    CalculateNormal(id.x);
}

[numthreads(BLOCKSIZE, 1, 1)]
void Bulge(uint id : SV_DispatchThreadID)
{
    Particle p = ParticleRWBuffer[id.x];

    float bulgeDistance = 0;
    float thetaL, thetaD, thetaC, radicand;
    for (uint i = 0; i < p.numLinks; i++)
    {
        float3 d = ParticleRWBuffer[p.links[i]].position - p.position;
        thetaL = acos(dot(d, p.normal) / length(d));
        thetaD = asin(length(d) * sin(thetaL) / _springLength);
        thetaC = 3.1415 - thetaD - thetaL;

        if (isnan(thetaC) || isinf(thetaC))
        {
            continue;
        }

        float radicand = pow(_springLength, 2) + length(d) * length(d) -
                        2.0 * length(d) * _springLength * cos(thetaC);

        if (radicand < 0.0)
        {
            radicand = 0;
        }

        bulgeDistance += sqrt(radicand);
    }

    bulgeDistance /= p.numLinks;

    p.delta += p.normal * bulgeDistance * 0.1;

    ParticleRWBuffer[id.x] = p;
}

[numthreads(BLOCKSIZE, 1, 1)]
void Plane(uint id : SV_DispatchThreadID)
{
    Particle p = ParticleRWBuffer[id.x];
    float3 planarTarget = (float3) 0.0;

    for (uint i = 0; i < p.numLinks; ++i)
    {
        planarTarget += ParticleRWBuffer[p.links[i]].position;
    }
    planarTarget /= p.numLinks;
    planarTarget = planarTarget - p.position;

    p.curvature = -1.0 * length(planarTarget) *
                         dot(p.normal, normalize(planarTarget));

    p.delta += planarTarget * _planarFactor;

    p.food += pow(max(p.curvature / 20.0f, 0.00001f),
                            _foodExponent);

    ParticleRWBuffer[id.x] = p;
}

[numthreads(BLOCKSIZE, 1, 1)]
void Spring(uint id : SV_DispatchThreadID)
{
    Particle p = ParticleRWBuffer[id.x];

    float3 target = (float3) 0.0;
    for (uint i = 0; i < p.numLinks;  i ++)
    {
        float3 d = ParticleRWBuffer[p.links[i]].position - p.position;
        d = normalize(d);
        d *= _springLength;
        target += d;
    }

    target /= p.numLinks;
    target *= _springLength;
    p.delta += target * _springFactor;

    ParticleRWBuffer[id.x] = p;
}

void Rotate(int p_index, int places)
{
    Particle p = ParticleRWBuffer[p_index];
    
    int scratch[MAX_LINKS];

    int target_index = 0;
    for (uint i = places; i < p.numLinks; i++)
    {
        scratch[target_index++] = p.links[i];
    }

    for (uint j = 0; j < places; j++)
    {
        scratch[target_index++] = p.links[j];
    }

    for (uint k = 0; k < p.numLinks; k++)
    {
        ParticleRWBuffer[p_index].links[k] = scratch[k];
    }
}


int FindLongestAxis(const Particle p)
{
    float minLength =  1e10;
    int shortest = -20;
    for (int i = 0; i < p.numLinks; i++)
    {
        float distance = length(p.position - ParticleRWBuffer[p.links[i]].position);
        int opposite = (i + (p.numLinks / 2)) % p.numLinks;
        distance += length(p.position - ParticleRWBuffer[p.links[opposite]].position);
        if (distance < minLength || i == 0)
        {
            minLength = distance;
            shortest  =  i;
        }
    }
    return shortest ;
}

void AddLink(int index, int toAdd)
{
    for (int k = 0; k < ParticleRWBuffer[index].numLinks; k++)
    {
        if (ParticleRWBuffer[index].links[k] == toAdd)
            return;
    }

    if (ParticleRWBuffer[index].numLinks < MAX_LINKS - 1)
    {
        ParticleRWBuffer[index].links[ParticleRWBuffer[index].numLinks] = toAdd;
        ParticleRWBuffer[index].numLinks++;
    }
}

void RemoveLink(int index, int toRemove)
{
    for (int i = 0; i < ParticleRWBuffer[index].numLinks; i++)
    {
        if (ParticleRWBuffer[index].links[i] == toRemove)
        {
            // shift back
            for (int j = i; j < ParticleRWBuffer[index].numLinks - 1 ; j++)
            {
                ParticleRWBuffer[index].links[j] = ParticleRWBuffer[index].links[j + 1];
            }

            //zero this out for debugging
            ParticleRWBuffer[index].links[ParticleRWBuffer[index].numLinks - 1] = -11;
            ParticleRWBuffer[index].numLinks--;
            return;
        }
    }
}

void SetLinks(int p_index, int b_index)
{
    OrderLinks(p_index);

    int firstIndex = FindLongestAxis(ParticleRWBuffer[p_index]);
    if (firstIndex != -20)
    {
        Rotate(p_index, firstIndex);
        int originalLinks[MAX_LINKS];
        int numLinksOriginal = ParticleRWBuffer[p_index].numLinks;

        for (int k = 0; k < ParticleRWBuffer[p_index].numLinks; k++)
        {
            originalLinks[k] = ParticleRWBuffer[p_index].links[k];
        }

        for (int i = 0; i <= numLinksOriginal / 2; i++)
        {
            AddLink(b_index, originalLinks[i]);
            AddLink(originalLinks[i], b_index);

            if (i != 0 && i != numLinksOriginal / 2)
            {
                RemoveLink(p_index, originalLinks[i]);
                RemoveLink(originalLinks[i], p_index);
            }
        }

        AddLink(p_index, b_index);
        AddLink(b_index, p_index);
    }
}

void SetPositions(int p_index, int b_index)
{
    float3 babyAverage = ParticleRWBuffer[p_index].position;
    for (int i = 0; i < ParticleRWBuffer[b_index].numLinks; ++i)
    {
        babyAverage += ParticleRWBuffer[ParticleRWBuffer[b_index].links[i]].position;
    }

    babyAverage /= ParticleRWBuffer[b_index].numLinks + 1;

    float3 parentAverage = ParticleRWBuffer[p_index].position;
    for (int j = 0; j < ParticleRWBuffer[p_index].numLinks; ++j)
    {
        parentAverage += ParticleRWBuffer[ParticleRWBuffer[p_index].links[j]].position;
    }

    parentAverage /= ParticleRWBuffer[p_index].numLinks + 1;

    // set positions
    ParticleRWBuffer[b_index].position = babyAverage;
    ParticleRWBuffer[p_index].position = parentAverage;
}


void DoSplit(int p_index)
{
    // Copy the particle for its baby
    Particle baby = ParticleRWBuffer[p_index];
    baby.numLinks = 0;
    baby.food = 0;

    for (int j = 0; j < MAX_LINKS; ++j)
    {
        baby.links[j] = -2;
    }

    ParticleRWBuffer[ _numParticles] = baby;
    ParticleRWBuffer.IncrementCounter();

    int baby_index = _numParticles;
    ParticleRWBuffer[p_index].food = 0;

    SetLinks(p_index, baby_index);
    SetPositions(p_index, baby_index);

    CalculateNormal(p_index);
    CalculateNormal(baby_index);
}

[numthreads(BLOCKSIZE, 1, 1)]
void Split(uint id : SV_DispatchThreadID)
{
    if (id.x < _numParticles)
    {
      if (ParticleRWBuffer[id.x].food > _threshold && 
             _frameNum % _numParticles == id.x)
   
     //   if (_frameNum % 60 == 0 &&
  //        _frameNum / 60 == id.x)
            
      //  if (_frameNum ==30  && 5 == id.x)
        {
            DoSplit(id.x);
        }
    }
}

[numthreads(BLOCKSIZE, 1, 1)]
void Integrate(uint id : SV_DispatchThreadID)
{
    Particle p = ParticleRWBuffer[id.x];
    p.position += p.delta * _dampening;
    p.delta = (float3) 0.0;
    ParticleRWBuffer[id.x] = p;
}


[numthreads(BLOCKSIZE, 1, 1)]
void RotateTest(uint id : SV_DispatchThreadID)
{
    ReverseLinks(id.x);
}